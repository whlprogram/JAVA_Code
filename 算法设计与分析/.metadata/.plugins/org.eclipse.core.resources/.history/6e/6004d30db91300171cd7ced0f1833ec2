package MergeSort;

public class MergeSort {//合并排序

	/**
	 * @param args
	 */
	public static int b[];
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
	}
	//合并排序递归算法
	public static void mergeSort(int a[], int left, int right){
		if(left < right){//至少有两个元素
			int i = (left+right)/2;//取中点
			mergeSort(a, left, right);
			mergeSort(a, i+1, right);
			Merge(a, b, left, i, right);//合并到数组b
			Copy(a, b, left, right);//复制回数组a
		}
	}
	//合并排序非递归算法
	public static void mergeSort1(int a[], int n){
		 b = new int[n];
		 int s = 1;
		 while(s < n){
			 MergePass(a, b, s, n);//合并到数组b
			 s += s;
			 MergePass(b, a, s, n);//合并到数组a
			 s += s;
		 }
	}
	public static void MergePass(int x[], int y[], int s, int n){//合并大小为s的相邻子数组
		int i = 0;
		while(i <= n-2*s){//合并大小为s的相邻2段子数组
			Merge(x, y, i, i+s-1, i+2*s-1);
			i = i + 2*s;
		}
		//剩下的元素个数少于2s
		if(i+s < n)
			Merge(x, y, i, i+s-1, n-1);
		else
			for(int j=i; j<=n-1; j++)
				y[j] = x[j];		
	}
	public static void Merge(int c[], int d[], int e, int m, int r){//合并c[e:m]和c[m+1:r]到d[e:r]
		int i = e, j = m+1, k = e;
		while( (i<=m) && (j<=r) ){
			if(c[i] <= c[j])
				d[k++] = c[i++];
			else
				d[k++] = c[j++];
		}
		if(i > m)
			for(int q=j; q<=r; q++)
				d[k++] = c[q];
		else
			for(int q=i; q<=m; q++)
				d[k++] = c[q];
	}
	public static void Copy(int a[], int b[], int m, int n){
		for(int i=m; i<=n; i++)
			a[i] = b[i];
	}

}
